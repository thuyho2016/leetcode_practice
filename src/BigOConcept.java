
/*
  n - size of the input
 
O(1) time - Constant Time
1. Accessing Array Index (int a = ARR[5];)
2. Inserting a node in Linked List & Array
3. Pushing and Poping on Stack
4. Insertion and Removal from Queue
5. HashMap for insert/access/search/delete
5. Finding out the parent or left/right child of a node in a tree stored in Array
6. Jumping to Next/Previous element in Doubly Linked List
and you can find a million more such examples...
7.

O(n) time - Linear time
1. Search/Traverse element in an array
2. Search element in a linked list
3. Linear Search
4. Deletion of a specific element in a Linked List (Not sorted)
5. Comparing two strings
6. Checking for Palindrome
7. Counting/Bucket Sort

O(log n) time - Logarithmic
1. Binary Search
2. Finding largest/smallest number in a binary search tree
3. Certain Divide and Conquer Algorithms based on Linear functionality
4. Calculating Fibonacci Numbers - Best Method
The basic premise here is NOT using the complete data, and reducing the problem size with every iteration

O(nlogn) time  - Linearithmic Time
1. Merge Sort
2. Heap Sort
3. Quick Sort
4. Certain Divide and Conquer Algorithms based on optimizing O(n^2) algorithms
The factor of 'log n' is introduced by bringing into consideration Divide and Conquer. Some of these algorithms are the best optimized ones and used frequently.

O(n^2) time - Quadric Time
1. Bubble Sort
2. Insertion Sort
3. Selection Sort
4. Traversing a simple 2D array

O(n^3) - Cubic Time
O(n!) - Factorial Time 

Time complexity : O(Nlogk) where k is the number of linked lists.
n is the total number of nodes in two lists.

			Array(unsorted/sorted ) LinkedList  Binary Search 
Search x    O(n)    O(logn)			 	0(n)		O(logn)
Insert x  	O(1)	O(n)	 			0(1)		O(logn)
Remove x	0(n)	O(n)	 			O(n)		O(logn)


https://www.bigocheatsheet.com/

*/